"use client";
import { client, server,utils } from "@passwordless-id/webauthn";
import {
  AuthenticationEncoded,
  AuthenticationParsed,
  RegistrationEncoded,
  RegistrationParsed,
} from "@passwordless-id/webauthn/dist/esm/types";
import { useEffect, useState } from "react";

export function MyButton() {
  const [registrationArray, setRegistrationArray] = useState<RegistrationParsed[]>(() => {
    const storedArray = typeof window !== 'undefined' ? localStorage.getItem("registrationArray") : null;
    return storedArray ? JSON.parse(storedArray) : [];
  });

  const [authentications, setAuthentications] = useState<AuthenticationParsed[]>(() => {
    const storedArray = typeof window !== 'undefined' ? localStorage.getItem("authenticationArray") : null;
    return storedArray ? JSON.parse(storedArray) : [];
  });
  
  useEffect(() => {
    localStorage.setItem("registrationArray", JSON.stringify(registrationArray));
  }, [registrationArray]);

  useEffect(() => {
    localStorage.setItem("authenticationArray", JSON.stringify(authentications));
  }, [authentications]);
  
  async function register() {
    try {
      // signing String to ArrayBuffer
      // timestamp should be surrounded by '-' and message
      let challenge = await createChallenge('FIDO2.TEST.regjij-'+ (Date.now()+ 60000).toString()+ '-  hello');
      // The challenge is a random string generated by the server and must be URL safe
      // challenge to be timestamp converted to base64
      let registration = await client.register("bob", challenge);
      let vertify = await VerifyRegistration(registration, challenge);
    } catch (e) {
      alert(e);
    }
  }

  async function login() {
    
    // The challenge is a random string generated by the server and must be URL safe
    // challenge to be timestamp converted to base64
    console.log("Authenticating...");
    let registration: RegistrationParsed = await getRegistration("bob");
    let authentication = await getAuthentication(registration.credential.id);
    if (!registration) {
      alert("Registration not found");
      return "Registration not found";
    }
    if (authentication != null) {
      alert("Authentication not found");
      let existChallenge = authentication.client.challenge;
      let originArrayBuffer = utils.parseBase64url(existChallenge);
      let originChallenge = utils.parseBuffer(originArrayBuffer);
      let originTimestamp = originChallenge.split('-')[1];
      if (Number(originTimestamp) > Date.now()) {
        alert("session is already exist");
        return "session is already exist";
      }
    }   
    let challenge = await createChallenge("FIDO2.TEST.login -"+ (Date.now()+ 60000).toString()+ "-hello");
    try {
      let authentication = await client.authenticate(
        [registration.credential.id],
        challenge
      );
      let login = Verifylogin(authentication, challenge);
    } catch (e) {
      alert(e);
    }
  }

  async function getRegistration(
    username: string
  ): Promise<RegistrationParsed> {
    for (const registration of registrationArray) {
      if (registration.username === username) {
        return registration;
      }
    }
    throw new Error("Registration not found");
  }

  async function getAuthentication(
    credentialId: string
  ): Promise<AuthenticationParsed | null> {
    for (const authentication of authentications) {
      if (authentication.credentialId === credentialId) {
        return authentication;
      }
    }
    return null;
  }

  async function VerifyRegistration(
    registration: RegistrationEncoded,
    challenge: string
  ) {
    console.log("Verifying...");
    try {
      alert(challenge);
      const expected = {
        challenge: challenge, // whatever was randomly generated by the server
        origin: "http://localhost:3000",
      };
      const registrationParsed = await server.verifyRegistration(
        registration,
        expected
      );
      alert(JSON.stringify(registrationParsed));
      setRegistrationArray((prevArray) => {
        const index = prevArray.findIndex((reg) => reg.username === registrationParsed.username);
        if (index !== -1) {
          prevArray[index] = registrationParsed;
          return [...prevArray];
        } else {
          return [...prevArray, registrationParsed];
        }
      });
    } catch (e) {
      alert(e);
    }
  }

  async function Verifylogin(
    authentication: AuthenticationEncoded,
    challenge: string
  ) {
    const registration = registrationArray.find((reg) => reg.credential.id === authentication.credentialId);
    alert(JSON.stringify(registration));
    if (!registration) {
      throw new Error("Registration not found");
    }
    const expected = {
      challenge: challenge,
      origin: "http://localhost:3000", //符合的origin
      userVerified: true, // 若在authentication options 中`userVerification` 是`required` (預設值) 則此值必須是`true`
    };
    const authenticationParsed: AuthenticationParsed =
      await server.verifyAuthentication(
        authentication,
        registration?.credential,
        expected
      );
    
    setAuthentications((prevArray) => {
      const index = prevArray.findIndex((auth) => auth.credentialId === authenticationParsed.credentialId);
      if (index !== -1) {
        prevArray[index] = authenticationParsed;
        return [...prevArray];
      } else {
        return [...prevArray, authenticationParsed];
      }
    })

    if (authenticationParsed !== undefined) {
      alert("Authentication successful");
      return "Authentication successful";
    }
  }

  async function createChallenge(
    message: string
  ) {
    let ArrayBuffer = utils.toBuffer(message);
    let challenge = utils.toBase64url(ArrayBuffer);
    challenge = challenge.replace(/=/g, "");
    return challenge;
  };

  return (
    <div>
      <button
        className={`mb-3 text-2xl font-semibold`}
        onClick={() => register()}
      >
        register
      </button>
      <br />
      <button className={`mb-3 text-2xl font-semibold`} onClick={() => login()}>
        login
      </button>
      <br />
    </div>
  );
}
